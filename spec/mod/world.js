require("world",function(r,o){function t(){return l(e,arguments)}function n(r,o,t){var n=this._gl,a=this._prg,i=this._arrAttributes.BYTES_PER_ELEMENT;a.use(),n.disable(n.CULL_FACE),n.cullFace(n.FRONT),a.$uniWidth=o,a.$uniHeight=t,a.$uniTime=r,a.$uniLookX=this.lookX,a.$uniLookY=this.lookY,a.$uniLookZ=this.lookZ,a.$uniLookPhi=this.lookPhi,a.$uniLookTheta=this.lookTheta,a.$uniLookRho=this.lookRho,n.bindBuffer(n.ARRAY_BUFFER,this._bufAttributes),n.bufferData(n.ARRAY_BUFFER,this._arrAttributes,n.STATIC_DRAW),n.enableVertexAttribArray(a.attribs.attPosition),n.vertexAttribPointer(a.attribs.attPosition,3,n.FLOAT,!1,6*i,0),n.enableVertexAttribArray(a.attribs.attColor),n.vertexAttribPointer(a.attribs.attColor,3,n.FLOAT,!1,6*i,3*i),n.enable(n.DEPTH_TEST),n.drawArrays(n.TRIANGLES,0,this._arrAttributes.length/6)}function a(r,o,t,n,a,i,e,l,c,h,s,u,f,m,v){return[r,o,t,f,m,v,n,a,i,f,m,v,e,l,c,f,m,v,r,o,t,f,m,v,e,l,c,f,m,v,h,s,u,f,m,v]}function i(){var r,o,t=[];for(r=0;r<arguments.length;r++)o=arguments[r],t=t.concat(a.apply(null,o));return t}var e={en:{}},l=require("$").intl,c=require("levels"),h=require("tfw.webgl"),s=function(r){this._gl=r,this._prg=new h.Program(r,{vert:u["vert-perspective"],frag:u["frag-unicolor"]}),this.lookTheta=0,this.lookPhi=Math.PI/4,this.lookRho=10};s.prototype.loadTerrain=function(r){var o=0,t=.5,n=0,a=.6,e=.3,l=0,h=.4,s=.2,u=0,f=[],m=c[r].alti,v=m.length,g=m[0].length;this.lookX=Math.floor(g/2)+.5,this.lookY=Math.floor(v/2)+.5,this.lookZ=m[Math.floor(v/2)][Math.floor(g/2)],m.forEach(function(r,c){r.forEach(function(r,m){r<0||(f=f.concat(i([m+0,c+0,r,m+0,c+1,r,m+1,c+1,r,m+1,c+0,r,o,t,n],[m+0,c+0,r,m+1,c+0,r,m+1,c+0,-2,m+0,c+0,-2,a,e,l],[m+1,c+1,r,m+0,c+1,r,m+0,c+1,-2,m+1,c+1,-2,1,0,0],[m+0,c+0,r,m+0,c+0,-2,m+0,c+1,-2,m+0,c+1,r,h,s,u],[m+1,c+0,-2,m+1,c+0,r,m+1,c+1,r,m+1,c+1,-2,.5,.5,u])))})}),console.info("[world] arr.length / 6=...",f.length/6),this._arrAttributes=new Float32Array(f),this._bufAttributes=this._gl.createBuffer()},s.prototype.render=function(r,o,t){var a=this._gl;a.viewport(0,0,o,t),a.clearColor(0,0,1,1),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),n.call(this,r,o,t)},o.exports=s;var u={"vert-perspective":"uniform float uniWidth;\r\nuniform float uniHeight;\r\nuniform float uniTime;\r\nuniform float uniLookX;\r\nuniform float uniLookY;\r\nuniform float uniLookZ;\r\nuniform float uniLookPhi;\r\nuniform float uniLookTheta;\r\nuniform float uniLookRho;\r\n\r\nattribute vec3 attPosition;\r\nattribute vec3 attColor;\r\n\r\nvarying vec3 varColor;\r\nvarying float varHeight;\r\n\r\nconst float DEPTH = 27.0;\r\nconst float DIST = 50.0;\r\nconst float ZOOM = 64.0;\r\n\r\nconst float PI = 3.141592653589793;\r\n  \r\nvoid main() {\r\n  float theta = uniTime * 0.00012 * PI;\r\n  float phi = (1.0 + sin(uniTime * 0.000842)) * .1 * PI;\r\n  float rho = 50.0;\r\n\r\n  float cosPhi = cos(phi);      // 1\r\n  float sinPhi = sin(phi);      // 0\r\n  float cosTheta = cos(theta);  // 1\r\n  float sinTheta = sin(theta);  // 0\r\n  \r\n  float camX = cosPhi * cosTheta;    // 1\r\n  float camY = cosPhi * sinTheta;    // 0\r\n  float camZ = sinPhi;               // 0\r\n\r\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\r\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\r\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\r\n\r\n  camX = camX * rho + uniLookX;\r\n  camY = camY * rho + uniLookY;\r\n  camZ = camZ * rho + uniLookZ;\r\n\r\n  camX = -0.0;\r\n  camY = -0.0;\r\n  camZ = -0.0;\r\n  \r\n  mat4 cameraMat = mat4(camVX.x, camVY.x, camVZ.x, 0.0,\r\n                        camVX.y, camVY.y, camVZ.y, 0.0,\r\n                        camVX.z, camVY.z, camVZ.z, 0.0,\r\n                        -camX,     -camY,   -camZ, 1.0);\r\n\r\n  vec4 pos = cameraMat * vec4(attPosition - vec3(uniLookX, uniLookY, uniLookZ), 1.0);\r\n  float zz = pos.z;\r\n  float xx = pos.x / uniWidth;\r\n  float yy = pos.y / uniHeight;\r\n  float w = ZOOM * DEPTH / (DEPTH + zz);\r\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\r\n  \r\n  varColor = attColor; \r\n  varHeight = attPosition.z;\r\n}                \r\n","frag-unicolor":"precision mediump float;\r\n\r\nvarying vec3 varColor;\r\nvarying float varHeight;\r\n\r\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\r\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\nvoid main() {\r\n  float alpha;\r\n  \r\n  gl_FragColor = vec4(varColor, 1.0);\r\n\r\n  if (varHeight < -1.0) {\r\n    if (varHeight > -1.1) {\r\n      gl_FragColor = BLUE;\r\n    } else {\r\n      alpha = -varHeight * .5;\r\n      gl_FragColor = mix( gl_FragColor, BLUE, alpha );\r\n    }\r\n  } else {\r\n    alpha = clamp((varHeight + 1.0) / 8.0, 0.0, 1.0);\r\n    gl_FragColor = mix( gl_FragColor, WHITE, alpha );\r\n  }\r\n}\r\n"};o.exports._=t});
//# sourceMappingURL=world.js.map