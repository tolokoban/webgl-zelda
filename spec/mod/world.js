require("world",function(o,t){function n(){return l(e,arguments)}function i(o,t,n){var i=this._gl,a=this._prg,r=this._arrAttributes.BYTES_PER_ELEMENT;a.use(),i.disable(i.CULL_FACE),i.cullFace(i.FRONT),a.$uniWidth=t,a.$uniHeight=n,a.$uniTime=o,a.$uniLookX=this.lookX,a.$uniLookY=this.lookY,a.$uniLookZ=this.lookZ,a.$uniLookPhi=this.lookPhi,a.$uniLookTheta=this.lookTheta,a.$uniLookRho=this.lookRho,i.bindBuffer(i.ARRAY_BUFFER,this._bufAttributes),i.bufferData(i.ARRAY_BUFFER,this._arrAttributes,i.STATIC_DRAW),i.enableVertexAttribArray(a.attribs.attPosition),i.vertexAttribPointer(a.attribs.attPosition,3,i.FLOAT,!1,6*r,0),i.enableVertexAttribArray(a.attribs.attColor),i.vertexAttribPointer(a.attribs.attColor,3,i.FLOAT,!1,6*r,3*r),i.enable(i.DEPTH_TEST),i.drawArrays(i.TRIANGLES,0,this._arrAttributes.length/6),this.worldTerrainEdges.lookX=this.lookX,this.worldTerrainEdges.lookY=this.lookY,this.worldTerrainEdges.lookZ=this.lookZ,this.worldTerrainEdges.lookTheta=this.lookTheta,this.worldTerrainEdges.lookPhi=this.lookPhi,this.worldTerrainEdges.lookRho=this.lookRho,this.worldTerrainEdges.render(o,t,n)}function a(o,t,n,i,a,r,e,l,h,s,c,u,f,m,g){return[o,t,n,f,m,g,i,a,r,f,m,g,e,l,h,f,m,g,o,t,n,f,m,g,e,l,h,f,m,g,s,c,u,f,m,g]}function r(){var o,t,n=[];for(o=0;o<arguments.length;o++)t=arguments[o],n=n.concat(a.apply(null,t));return n}var e={en:{}},l=require("$").intl,h=require("levels"),s=require("tfw.webgl"),c=require("world.terrain.edges"),u=function(o){this._gl=o,this._prg=new s.Program(o,{vert:f["vert-perspective"],frag:f["frag-unicolor"]}),this.lookTheta=0,this.lookPhi=Math.PI/4,this.lookRho=10,this.worldTerrainEdges=new c(o)};u.prototype.loadTerrain=function(o){this.worldTerrainEdges.loadTerrain(o);var t=0,n=.3,i=0,a=.4,e=.2,l=0,s=.3,c=.15,u=0,f=[],m=h[o].alti,g=m.length,v=m[0].length;this.lookX=Math.floor(v/2)+.5,this.lookY=Math.floor(g/2)+.5,this.lookZ=m[Math.floor(g/2)][Math.floor(v/2)],m.forEach(function(o,h){o.forEach(function(o,m){o<0||(f=f.concat(r([m+0,h+0,o,m+0,h+1,o,m+1,h+1,o,m+1,h+0,o,t,n,i],[m+0,h+0,o,m+1,h+0,o,m+1,h+0,-2,m+0,h+0,-2,a,e,l],[m+1,h+1,o,m+0,h+1,o,m+0,h+1,-2,m+1,h+1,-2,a,e,l],[m+0,h+0,o,m+0,h+0,-2,m+0,h+1,-2,m+0,h+1,o,s,c,u],[m+1,h+0,-2,m+1,h+0,o,m+1,h+1,o,m+1,h+1,-2,s,c,u])))})}),console.info("[world] arr.length / 6=...",f.length/6),this._arrAttributes=new Float32Array(f),this._bufAttributes=this._gl.createBuffer()},u.prototype.render=function(o,t,n){var a=this._gl;a.viewport(0,0,t,n),a.clearColor(0,0,1,1),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT),i.call(this,o,t,n)},t.exports=u;var f={"vert-perspective":"uniform float uniWidth;\nuniform float uniHeight;\nuniform float uniTime;\nuniform float uniLookX;\nuniform float uniLookY;\nuniform float uniLookZ;\nuniform float uniLookPhi;\nuniform float uniLookTheta;\nuniform float uniLookRho;\n\nattribute vec3 attPosition;\nattribute vec3 attColor;\n\nvarying vec3 varColor;\nvarying float varHeight;\n\nconst float DEPTH = 27.0;\nconst float DIST = 50.0;\nconst float ZOOM = 64.0;\n\nconst float PI = 3.141592653589793;\n  \nvoid main() {\n  float theta = uniTime * 0.00012 * PI;\n  float phi = (1.0 + sin(uniTime * 0.000842)) * .1 * PI;\n  float rho = 50.0;\n\n  float cosPhi = cos(phi);      // 1\n  float sinPhi = sin(phi);      // 0\n  float cosTheta = cos(theta);  // 1\n  float sinTheta = sin(theta);  // 0\n  \n  float camX = cosPhi * cosTheta;    // 1\n  float camY = cosPhi * sinTheta;    // 0\n  float camZ = sinPhi;               // 0\n\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\n\n  camX = camX * rho + uniLookX;\n  camY = camY * rho + uniLookY;\n  camZ = camZ * rho + uniLookZ;\n\n  camX = -0.0;\n  camY = -0.0;\n  camZ = -0.0;\n  \n  mat4 cameraMat = mat4(camVX.x, camVY.x, camVZ.x, 0.0,\n                        camVX.y, camVY.y, camVZ.y, 0.0,\n                        camVX.z, camVY.z, camVZ.z, 0.0,\n                        -camX,     -camY,   -camZ, 1.0);\n\n  vec4 pos = cameraMat * vec4(attPosition - vec3(uniLookX, uniLookY, uniLookZ), 1.0);\n  float zz = pos.z;\n  float xx = pos.x / uniWidth;\n  float yy = pos.y / uniHeight;\n  float w = ZOOM * DEPTH / (DEPTH + zz);\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\n  \n  varColor = attColor; \n  varHeight = attPosition.z;\n}                \n","frag-unicolor":"precision mediump float;\n\nvarying vec3 varColor;\nvarying float varHeight;\n\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\n\nvoid main() {\n  float alpha;\n  \n  gl_FragColor = vec4(varColor, 1.0);\n\n  if (varHeight < -1.0) {\n    if (varHeight > -1.1) {\n      gl_FragColor = BLUE;\n    } else {\n      alpha = -varHeight * .5;\n      gl_FragColor = mix( gl_FragColor, BLUE, alpha );\n    }\n  } else {\n    alpha = clamp((varHeight + 1.0) / 8.0, 0.0, 1.0);\n    gl_FragColor = mix( gl_FragColor, WHITE, alpha );\n  }\n}\n"};t.exports._=n});
//# sourceMappingURL=world.js.map