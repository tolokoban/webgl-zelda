require("world",function(r,t){function n(){return u(a,arguments)}function o(r,t,n){var o=this._gl,i=this._prg,e=this._arrAttributes.BYTES_PER_ELEMENT;i.use(),o.uniform1f(i.uniforms.uniWidth,t),o.uniform1f(i.uniforms.uniHeight,n),o.uniform1f(i.uniforms.uniTime,r),o.bindBuffer(o.ARRAY_BUFFER,this._bufAttributes),o.bufferData(o.ARRAY_BUFFER,this._arrAttributes,o.STATIC_DRAW),o.enableVertexAttribArray(i.attribs.attPosition),o.vertexAttribPointer(i.attribs.attPosition,3,o.FLOAT,!1,6*e,0),o.enableVertexAttribArray(i.attribs.attColor),o.vertexAttribPointer(i.attribs.attColor,3,o.FLOAT,!1,6*e,3*e),o.enable(o.DEPTH_TEST),o.drawArrays(o.TRIANGLES,0,this._arrAttributes.length/6)}function i(r,t,n,o,i,e,a,u,s,c,l,f,v,m,T){return[r,t,n,v,m,T,o,i,e,v,m,T,a,u,s,v,m,T,r,t,n,v,m,T,a,u,s,v,m,T,c,l,f,v,m,T]}function e(){var r,t,n=[];for(r=0;r<arguments.length;r++)t=arguments[r],n=n.concat(i.apply(null,t));return console.info("[world] attributes=...",n),n}var a={en:{}},u=require("$").intl,s=require("levels"),c=require("tfw.webgl"),l=function(r){this._gl=r,this._prg=new c.Program(r,{vert:f["vert-perspective"],frag:f["frag-unicolor"]})};l.prototype.loadTerrain=function(r){var t=0,n=1,o=0,i=.8,a=.4,u=0,c=.4,l=.2,f=0,v=[],m=s[r].alti;m.forEach(function(r,s){r.forEach(function(r,m){r<0||(v=v.concat(e([m+0,s+0,r,m+0,s+1,r,m+1,s+1,r,m+1,s+0,r,t,n,o],[m+0,s+0,r,m+1,s+0,r,m+1,s+0,-1,m+0,s+0,-1,i,a,u],[m+0,s+0,r,m+0,s+0,-1,m+0,s+1,-1,m+0,s+1,r,c,l,f])))})}),this._arrAttributes=new Float32Array(v),this._bufAttributes=this._gl.createBuffer()},l.prototype.render=function(r,t,n){var i=this._gl;i.viewport(0,0,t,n),i.clearColor(0,0,0,1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),o.call(this,r,t,n)},t.exports=l;var f={"vert-perspective":"uniform float uniWidth;\r\nuniform float uniHeight;\r\nuniform float uniTime;\r\nuniform vec3 uniLookAt;\r\n\r\nattribute vec3 attPosition;\r\nattribute vec3 attColor;\r\n\r\nvarying vec3 varColor;\r\n\r\nconst float DEPTH = 700.0;\r\nconst float DIST = 50.0;\r\n\r\nconst float ZOOM = 64.0;\r\n\r\nvoid main() {\r\n  vec3 cameraPos = vec3(0.0, -DIST, DIST);\r\n  vec3 z = normalize(vec3( 0.0, DIST + DIST * .5 * cos(uniTime * .001), -DIST ));\r\n  vec3 y = vec3( 0.0, -z.z, z.y );\r\n  vec3 x = vec3(1.0, 0.0, 0.0);\r\n  mat4 cameraMat = mat4(x.x, x.y, x.z, -cameraPos.x,\r\n                        y.x, y.y, y.z, -cameraPos.y,\r\n                        z.x, z.y, z.z, -cameraPos.z,\r\n                        0.0, 0.0, 0.0, 1.0);\r\n\r\n  vec4 pos = cameraMat * vec4(attPosition * ZOOM, 1.0);\r\n\r\n  //vec3 pos = attPosition * ZOOM;\r\n  float zz = pos.z;\r\n  float xx = pos.x / uniWidth;\r\n  float yy = pos.y / uniHeight;\r\n  float w = DEPTH / (DEPTH + zz);\r\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\r\n  \r\n  varColor = attColor; \r\n}                \r\n","frag-unicolor":"precision mediump float;\r\n\r\nvarying vec3 varColor;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(varColor, 1.0);\r\n}\r\n"};t.exports._=n});
//# sourceMappingURL=world.js.map