require("world.terrain.edges",function(o,t){function n(){return a(i,arguments)}var i={en:{}},a=require("$").intl,r=require("levels"),e=require("tfw.webgl"),l=function(o){this._gl=o,this._prg=new e.Program(o,{vert:h["vert-perspective"],frag:h["frag-unicolor"]})};l.prototype.loadTerrain=function(o){var t=[],n=r[o].alti,i=n.length,a=n[0].length;n.forEach(function(o,r){o.forEach(function(o,e){o<0||(0!=e&&n[r][e-1]==o||t.push(e,r,o,e,r+1,o),e!=a-1&&n[r][e+1]==o||t.push(e+1,r,o,e+1,r+1,o),0!=r&&n[r-1][e]==o||t.push(e,r,o,e+1,r,o),r!=i-1&&n[r+1][e]==o||t.push(e,r+1,o,e+1,r+1,o))})}),this._arrAttributes=new Float32Array(t),this._bufAttributes=this._gl.createBuffer()},l.prototype.render=function(o,t,n){var i=this._gl,a=this._prg,r=this._arrAttributes.BYTES_PER_ELEMENT;a.use(),a.$uniWidth=t,a.$uniHeight=n,a.$uniTime=o,a.$uniLookX=this.lookX,a.$uniLookY=this.lookY,a.$uniLookZ=this.lookZ,a.$uniLookPhi=this.lookPhi,a.$uniLookTheta=this.lookTheta,a.$uniLookRho=this.lookRho,i.bindBuffer(i.ARRAY_BUFFER,this._bufAttributes),i.bufferData(i.ARRAY_BUFFER,this._arrAttributes,i.STATIC_DRAW),i.enableVertexAttribArray(a.attribs.attPosition),i.vertexAttribPointer(a.attribs.attPosition,3,i.FLOAT,!1,3*r,0),i.enable(i.DEPTH_TEST),i.drawArrays(i.LINES,0,this._arrAttributes.length/3)},t.exports=l;var h={"vert-perspective":"uniform float uniWidth;\nuniform float uniHeight;\nuniform float uniTime;\nuniform float uniLookX;\nuniform float uniLookY;\nuniform float uniLookZ;\nuniform float uniLookPhi;\nuniform float uniLookTheta;\nuniform float uniLookRho;\n\nattribute vec3 attPosition;\nattribute vec3 attColor;\nattribute float attThreshold;\n\nvarying vec3 varColor;\nvarying float varHeight;\nvarying float varThreshold;\n\nconst float DEPTH = 270.0;\nconst float ZOOM = 100000.0;\n\nconst float PI = 3.141592653589793;\n  \nvoid main() {\n  float theta = uniTime * 0.00012 * PI;\n  float phi = (1.0 + sin(uniTime * 0.000842)) * .1 * PI;\n  float rho = 3.0;\n  float lookX = uniLookX;\n  float lookY = uniLookY;\n  float lookZ = uniLookZ;\n\n  float cosPhi = cos(phi);      // 1\n  float sinPhi = sin(phi);      // 0\n  float cosTheta = cos(theta);  // 1\n  float sinTheta = sin(theta);  // 0\n  \n  float camX = cosPhi * cosTheta;    // 1\n  float camY = cosPhi * sinTheta;    // 0\n  float camZ = sinPhi;               // 0\n\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\n\n  camX = camX * rho + lookX;\n  camY = camY * rho + lookY;\n  camZ = camZ * rho + lookZ;\n\n  mat3 cameraMat = mat3(camVX.x, camVY.x, camVZ.x,\n                        camVX.y, camVY.y, camVZ.y,\n                        camVX.z, camVY.z, camVZ.z);\n\n  vec3 pos = cameraMat * (attPosition - vec3(camX, camY, camZ));\n  float zz = pos.z;\n  float xx = pos.x / uniWidth;\n  float yy = pos.y / uniHeight;\n  float w = ZOOM / (rho * (DEPTH + zz));\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\n  \n  varColor = attColor; \n  varHeight = attPosition.z;\n  varThreshold = attThreshold;\n}                \n","frag-unicolor":"precision mediump float;\n\nvoid main() {\n  gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n"};t.exports._=n});
//# sourceMappingURL=world.terrain.edges.js.map