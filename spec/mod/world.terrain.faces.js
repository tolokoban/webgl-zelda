require("world.terrain.faces",function(r,o){function n(){return l(e,arguments)}function a(r,o,n){if(n<0||n>=r.length)return-3;var a=r[n];if(o<0||o>=a.length)return-3;var t=a[o];return t<0?-3:t}function t(r,o,n,t){var i=0;return t!=a(r,o+0,n+0)&&(i=1),t!=a(r,o-1,n+0)&&(i=1),t!=a(r,o-1,n-1)&&(i=1),t!=a(r,o+0,n-1)&&(i=1),i}function i(r,o,n,a,t,i,e,l,s,f,c,h,u,m,v,g){return"undefined"==typeof g&&(g=0),[r,o,n,u,m,v,g,a,t,i,u,m,v,g,e,l,s,u,m,v,g,r,o,n,u,m,v,g,e,l,s,u,m,v,g,f,c,h,u,m,v,g]}var e={en:{}},l=require("$").intl,s=require("levels"),f=require("tfw.webgl"),c=require("vertex-array"),h=function(r){this._gl=r,this._prgWalls=new f.Program(r,{vert:u.vert,frag:u.frag}),this._prgGround=new f.Program(r,{vert:u["vert-ground"],frag:u["frag-ground"]})};h.prototype.loadTerrain=function(r){var o=.4,n=.2,e=0,l=.3,f=.15,h=0,u=[],m=s[r].alti,v=(m.length,m[0].length,new c);m.forEach(function(r,o){r.forEach(function(r,n){if(!(r<0)){var a=t(m,n+0,o+0,r),i=t(m,n+0,o+1,r),e=t(m,n+1,o+1,r),l=t(m,n+1,o+0,r);v.add(n+0,o+0,r,a),v.add(n+0,o+1,r,i),v.add(n+1,o+1,r,e),v.add(n+1,o+1,r,e),v.add(n+1,o+0,r,l),v.add(n+0,o+0,r,a)}})}),this._ground=v.toBufferArrays(),m.forEach(function(r,t){r.forEach(function(r,s){if(!(r<0)){var c;c=a(m,s,t-1),c<r&&(u=u.concat(i(s+0,t+0,r,s+1,t+0,r,s+1,t+0,c,s+0,t+0,c,o,n,e,r))),c=a(m,s,t+1),c<r&&(u=u.concat(i(s+1,t+1,r,s+0,t+1,r,s+0,t+1,c,s+1,t+1,c,o,n,e,r))),c=a(m,s-1,t),c<r&&(u=u.concat(i(s+0,t+0,r,s+0,t+0,c,s+0,t+1,c,s+0,t+1,r,l,f,h,r))),c=a(m,s+1,t),c<r&&(u=u.concat(i(s+1,t+0,c,s+1,t+0,r,s+1,t+1,r,s+1,t+1,c,l,f,h,r)))}})}),console.info("[world] arrWalls.length / 7=...",u.length/7),this._arrWalls=new Float32Array(u),this._bufWalls=this._gl.createBuffer(),this._bufGroundVert=this._gl.createBuffer(),this._bufGroundElem=this._gl.createBuffer()},h.prototype.render=function(r,o,n){if(this._arrWalls){var a=this._gl,t=this._prgWalls,i=this._prgGround;a.enable(a.CULL_FACE),a.cullFace(a.BACK),a.enable(a.DEPTH_TEST),t.use(),t.$uniWidth=o,t.$uniHeight=n,t.$uniTime=r,t.$uniTimeFrag=r,t.$uniLookX=this.lookX,t.$uniLookY=this.lookY,t.$uniLookZ=this.lookZ,t.$uniLookPhi=this.lookPhi,t.$uniLookTheta=this.lookTheta,t.$uniLookRho=this.lookRho,a.bindBuffer(a.ARRAY_BUFFER,this._bufWalls),a.bufferData(a.ARRAY_BUFFER,this._arrWalls,a.STATIC_DRAW),t.enableVertexAttribFloat32Array("attPosition","attColor","attThreshold"),a.drawArrays(a.TRIANGLES,0,this._arrWalls.length/7),i.use(),i.$uniWidth=o,i.$uniHeight=n,i.$uniTime=r,i.$uniTimeFrag=r,i.$uniLookX=this.lookX,i.$uniLookY=this.lookY,i.$uniLookZ=this.lookZ,i.$uniLookPhi=this.lookPhi,i.$uniLookTheta=this.lookTheta,i.$uniLookRho=this.lookRho,a.bindBuffer(a.ARRAY_BUFFER,this._bufGroundVert),a.bufferData(a.ARRAY_BUFFER,this._ground.vert,a.STATIC_DRAW),i.enableVertexAttribFloat32Array("attPosition","attFlag"),a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,this._bufGroundElem),a.bufferData(a.ELEMENT_ARRAY_BUFFER,this._ground.elem,a.STATIC_DRAW),a.drawElements(a.TRIANGLES,this._ground.elem.length,a.UNSIGNED_SHORT,0)}},o.exports=h;var u={vert:"uniform float uniWidth;\r\nuniform float uniHeight;\r\nuniform float uniTime;\r\nuniform float uniLookX;\r\nuniform float uniLookY;\r\nuniform float uniLookZ;\r\nuniform float uniLookPhi;\r\nuniform float uniLookTheta;\r\nuniform float uniLookRho;\r\n\r\nattribute vec3 attPosition;\r\nattribute vec3 attColor;\r\nattribute float attThreshold;\r\n\r\nvarying vec3 varColor;\r\nvarying vec3 varPosition;\r\nvarying float varThreshold;\r\n\r\nconst float DEPTH = 270.0;\r\nconst float ZOOM = 100000.0;\r\n\r\nconst float PI = 3.141592653589793;\r\n  \r\nvoid main() {\r\n  float theta = uniLookTheta;\r\n  float phi = uniLookPhi;\r\n  float rho = uniLookRho;\r\n  float lookX = uniLookX;\r\n  float lookY = uniLookY;\r\n  float lookZ = uniLookZ;\r\n\r\n  float cosPhi = cos(phi);      // 1\r\n  float sinPhi = sin(phi);      // 0\r\n  float cosTheta = cos(theta);  // 1\r\n  float sinTheta = sin(theta);  // 0\r\n  \r\n  float camX = cosPhi * cosTheta;    // 1\r\n  float camY = cosPhi * sinTheta;    // 0\r\n  float camZ = sinPhi;               // 0\r\n\r\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\r\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\r\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\r\n\r\n  camX = camX * rho + lookX;\r\n  camY = camY * rho + lookY;\r\n  camZ = camZ * rho + lookZ;\r\n\r\n  mat3 cameraMat = mat3(camVX.x, camVY.x, camVZ.x,\r\n                        camVX.y, camVY.y, camVZ.y,\r\n                        camVX.z, camVY.z, camVZ.z);\r\n\r\n  vec3 pos = cameraMat * (attPosition - vec3(camX, camY, camZ));\r\n  float zz = pos.z;\r\n  float xx = pos.x / uniWidth;\r\n  float yy = pos.y / uniHeight;\r\n  float w = ZOOM / (rho * (DEPTH + zz));\r\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\r\n  \r\n  varColor = attColor; \r\n  varPosition = attPosition;\r\n  varThreshold = attThreshold;\r\n}                \r\n",frag:"precision mediump float;\r\n\r\nuniform float uniTimeFrag;\r\nvarying vec3 varColor;\r\nvarying vec3 varPosition;\r\nvarying float varThreshold;\r\n\r\nconst float PI = 3.141592653589793;\r\n\r\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\r\nconst vec4 GREEN = vec4(0.0, 0.7, 0.0, 1.0);\r\nconst vec4 WATER = vec4(0.5, 0.5, 1.0, 0.0);\r\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\nvoid main() {\r\n  // Niveau de la mer qui fluctue avec le temps.\r\n  float sea = -1.0 + sin(uniTimeFrag * .0010157) * .2;\r\n  float alpha;\r\n\r\n  // Couleur de base\r\n  gl_FragColor = vec4(varColor, 1.0);\r\n\r\n  if (varPosition.z < sea) {\r\n    // On est SOUS le niveau de la mer.\r\n    float threshold = sea - 0.2 + 0.1 * sin(4.0*(varPosition.x + varPosition.y) + uniTimeFrag * .004)\r\n      * sin(3.771*(varPosition.x - varPosition.y) + uniTimeFrag * .004);\r\n    if (varPosition.z > threshold) {\r\n      alpha = (varPosition.z - threshold)/(sea - threshold);\r\n      gl_FragColor = mix(WATER, BLUE, 1.0 - alpha);\r\n    } else {\r\n      alpha = -varPosition.z * .5;\r\n      gl_FragColor = mix( gl_FragColor, BLUE, alpha );\r\n    }\r\n  } else {\r\n    // On est au DESSUS du niveau de la mer.\r\n    alpha = clamp((varPosition.z + 1.0) / 8.0, 0.0, 1.0);\r\n    // Plus on monte, plus c'est clair.\r\n    gl_FragColor = mix( gl_FragColor, WHITE, alpha );\r\n    //LiserÃ© noir.\r\n    float diff = varThreshold - varPosition.z;\r\n    float petal = 0.2 * abs(sin((varPosition.x + varPosition.y) * 2.0 * PI));\r\n    if (diff > 0.0 && diff < petal) {\r\n      gl_FragColor = GREEN;\r\n    }\r\n    else if (diff > petal + 0.0 && diff < petal + .2) {\r\n      gl_FragColor = vec4(mix(gl_FragColor.rgb,\r\n                              vec3(0.0, 0.0, 0.0),\r\n                              (petal + .2 - diff) * 5.0),\r\n                          1.0);\r\n    }\r\n  }\r\n\r\n}\r\n","vert-ground":"attribute float attFlag;\r\nattribute vec3 attPosition;\r\n\r\nuniform float uniWidth;\r\nuniform float uniHeight;\r\nuniform float uniTime;\r\nuniform float uniLookX;\r\nuniform float uniLookY;\r\nuniform float uniLookZ;\r\nuniform float uniLookPhi;\r\nuniform float uniLookTheta;\r\nuniform float uniLookRho;\r\n\r\nvarying vec3 varPosition;\r\nvarying float varFlag;\r\n\r\nconst float DEPTH = 270.0;\r\nconst float ZOOM = 100000.0;\r\n\r\nconst float PI = 3.141592653589793;\r\n  \r\nvoid main() {\r\n  float theta = uniLookTheta;\r\n  float phi = uniLookPhi;\r\n  float rho = uniLookRho;\r\n  float lookX = uniLookX;\r\n  float lookY = uniLookY;\r\n  float lookZ = uniLookZ;\r\n\r\n  float cosPhi = cos(phi);      // 1\r\n  float sinPhi = sin(phi);      // 0\r\n  float cosTheta = cos(theta);  // 1\r\n  float sinTheta = sin(theta);  // 0\r\n  \r\n  float camX = cosPhi * cosTheta;    // 1\r\n  float camY = cosPhi * sinTheta;    // 0\r\n  float camZ = sinPhi;               // 0\r\n\r\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\r\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\r\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\r\n\r\n  camX = camX * rho + lookX;\r\n  camY = camY * rho + lookY;\r\n  camZ = camZ * rho + lookZ;\r\n\r\n  mat3 cameraMat = mat3(camVX.x, camVY.x, camVZ.x,\r\n                        camVX.y, camVY.y, camVZ.y,\r\n                        camVX.z, camVY.z, camVZ.z);\r\n\r\n  vec3 pos = cameraMat * (attPosition - vec3(camX, camY, camZ));\r\n  float zz = pos.z;\r\n  float xx = pos.x / uniWidth;\r\n  float yy = pos.y / uniHeight;\r\n  float w = ZOOM / (rho * (DEPTH + zz));\r\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\r\n  \r\n  varPosition = attPosition;\r\n  varFlag = attFlag;\r\n}                \r\n","frag-ground":"precision mediump float;\r\n\r\nuniform float uniTimeFrag;\r\n\r\nvarying vec3 varPosition;\r\nvarying float varFlag;\r\n\r\nconst float PI = 3.141592653589793;\r\n\r\nconst vec4 GREEN = vec4(0.0, 1.0, 0.0, 1.0);\r\nconst vec4 DARK_GREEN = vec4(0.0, 0.7, 0.0, 1.0);\r\n\r\nvoid main() {\r\n  if (varFlag < .7) gl_FragColor = GREEN;\r\n  else gl_FragColor = DARK_GREEN;\r\n  \r\n  return;\r\n  float x = mod(varPosition.x, 1.0);\r\n  float y = mod(varPosition.y, 1.0);\r\n  \r\n  if (x < .1 || x > .9) gl_FragColor = GREEN;\r\n  else gl_FragColor = DARK_GREEN;\r\n}\r\n"};o.exports._=n});
//# sourceMappingURL=world.terrain.faces.js.map