require("world.terrain.faces",function(t,o){function n(){return e(i,arguments)}function a(t,o,n){if(n<0||n>=t.length)return-2;var a=t[n];if(o<0||o>=a.length)return-2;var r=a[o];return r<0?-2:r}function r(t,o,n,a,r,i,e,l,h,c,f,s,u,v,m,g){return"undefined"==typeof g&&(g=0),[t,o,n,u,v,m,g,a,r,i,u,v,m,g,e,l,h,u,v,m,g,t,o,n,u,v,m,g,e,l,h,u,v,m,g,c,f,s,u,v,m,g]}var i={en:{}},e=require("$").intl,l=require("levels"),h=require("tfw.webgl"),c=function(t){this._gl=t,this._prg=new h.Program(t,{vert:f.vert,frag:f.frag})};c.prototype.loadTerrain=function(t){var o=0,n=.3,i=0,e=.4,h=.2,c=0,f=.3,s=.15,u=0,v=[],m=l[t].alti;m.length,m[0].length;m.forEach(function(t,l){t.forEach(function(t,g){if(!(t<0)){var T;v=v.concat(r(g+0,l+0,t,g+0,l+1,t,g+1,l+1,t,g+1,l+0,t,o,n,i,t)),T=a(m,g,l-1),T<t&&(v=v.concat(r(g+0,l+0,t,g+1,l+0,t,g+1,l+0,T,g+0,l+0,T,e,h,c,t))),T=a(m,g,l+1),T<t&&(v=v.concat(r(g+1,l+1,t,g+0,l+1,t,g+0,l+1,T,g+1,l+1,T,e,h,c,t))),T=a(m,g-1,l),T<t&&(v=v.concat(r(g+0,l+0,t,g+0,l+0,T,g+0,l+1,T,g+0,l+1,t,f,s,u,t))),T=a(m,g+1,l),T<t&&(v=v.concat(r(g+1,l+0,T,g+1,l+0,t,g+1,l+1,t,g+1,l+1,T,f,s,u,t)))}})}),console.info("[world] arr.length / 7=...",v.length/7),this._arrAttributes=new Float32Array(v),this._bufAttributes=this._gl.createBuffer()},c.prototype.render=function(t,o,n){var a=this._gl,r=this._prg,i=this._arrAttributes.BYTES_PER_ELEMENT;r.use(),a.enable(a.CULL_FACE),a.cullFace(a.BACK),r.$uniWidth=o,r.$uniHeight=n,r.$uniTime=t,r.$uniLookX=this.lookX,r.$uniLookY=this.lookY,r.$uniLookZ=this.lookZ,r.$uniLookPhi=this.lookPhi,r.$uniLookTheta=this.lookTheta,r.$uniLookRho=this.lookRho,a.bindBuffer(a.ARRAY_BUFFER,this._bufAttributes),a.bufferData(a.ARRAY_BUFFER,this._arrAttributes,a.STATIC_DRAW),a.enableVertexAttribArray(r.attribs.attPosition),a.vertexAttribPointer(r.attribs.attPosition,3,a.FLOAT,!1,7*i,0),a.enableVertexAttribArray(r.attribs.attColor),a.vertexAttribPointer(r.attribs.attColor,3,a.FLOAT,!1,7*i,3*i),a.enableVertexAttribArray(r.attribs.attThreshold),a.vertexAttribPointer(r.attribs.attThreshold,1,a.FLOAT,!1,7*i,6*i),a.enable(a.DEPTH_TEST),a.drawArrays(a.TRIANGLES,0,this._arrAttributes.length/7)},o.exports=c;var f={vert:"uniform float uniWidth;\nuniform float uniHeight;\nuniform float uniTime;\nuniform float uniLookX;\nuniform float uniLookY;\nuniform float uniLookZ;\nuniform float uniLookPhi;\nuniform float uniLookTheta;\nuniform float uniLookRho;\n\nattribute vec3 attPosition;\nattribute vec3 attColor;\nattribute float attThreshold;\n\nvarying vec3 varColor;\nvarying float varHeight;\nvarying float varThreshold;\n\nconst float DEPTH = 270.0;\nconst float ZOOM = 100000.0;\n\nconst float PI = 3.141592653589793;\n  \nvoid main() {\n  float theta = uniLookTheta;\n  float phi = uniLookPhi;\n  float rho = uniLookRho;\n  float lookX = uniLookX;\n  float lookY = uniLookY;\n  float lookZ = uniLookZ;\n\n  float cosPhi = cos(phi);      // 1\n  float sinPhi = sin(phi);      // 0\n  float cosTheta = cos(theta);  // 1\n  float sinTheta = sin(theta);  // 0\n  \n  float camX = cosPhi * cosTheta;    // 1\n  float camY = cosPhi * sinTheta;    // 0\n  float camZ = sinPhi;               // 0\n\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\n\n  camX = camX * rho + lookX;\n  camY = camY * rho + lookY;\n  camZ = camZ * rho + lookZ;\n\n  mat3 cameraMat = mat3(camVX.x, camVY.x, camVZ.x,\n                        camVX.y, camVY.y, camVZ.y,\n                        camVX.z, camVY.z, camVZ.z);\n\n  vec3 pos = cameraMat * (attPosition - vec3(camX, camY, camZ));\n  float zz = pos.z;\n  float xx = pos.x / uniWidth;\n  float yy = pos.y / uniHeight;\n  float w = ZOOM / (rho * (DEPTH + zz));\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\n  \n  varColor = attColor; \n  varHeight = attPosition.z;\n  varThreshold = attThreshold;\n}                \n",frag:"precision mediump float;\n\nvarying vec3 varColor;\nvarying float varHeight;\nvarying float varThreshold;\n\n\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\n\nvoid main() {\n  float alpha;\n\n  gl_FragColor = vec4(varColor, 1.0);\n  if (varHeight < -1.0) {\n    if (varHeight > -1.1) {\n      gl_FragColor = BLUE;\n    } else {\n      alpha = -varHeight * .5;\n      gl_FragColor = mix( gl_FragColor, BLUE, alpha );\n    }\n  } else {\n    alpha = clamp((varHeight + 1.0) / 8.0, 0.0, 1.0);\n    gl_FragColor = mix( gl_FragColor, WHITE, alpha );\n  }\n\n  float diff = varThreshold - varHeight;\n  if (diff > 0.0 && diff < .2) {\n    gl_FragColor = vec4(\n      mix(gl_FragColor.rgb, vec3(0.0, 0.0, 0.0), (.2 - diff) * 5.0),\n      1.0);\n  }\n}\n"};o.exports._=n});
//# sourceMappingURL=world.terrain.faces.js.map