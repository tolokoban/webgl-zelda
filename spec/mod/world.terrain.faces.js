require("world.terrain.faces",function(o,n){function a(){return l(e,arguments)}function t(o,n,a){if(a<0||a>=o.length)return-3;var t=o[a];if(n<0||n>=t.length)return-3;var i=t[n];return i<0?-3:i}function i(o,n,a,i){var r=0;return i!=t(o,n+0,a+0)&&(r+=1),i!=t(o,n-1,a+0)&&(r+=2),i!=t(o,n-1,a-1)&&(r+=4),i!=t(o,n+0,a-1)&&(r+=8),[[0,0],[-1,-1],[1,-1],[1,1],[1,1],[0,0],[1,0],[1,-1],[-1,1],[-1,0],[0,0],[-1,-1],[0,1],[-1,1],[1,1],[0,0]][r]}function r(o,n,a,t,i,r,e,l,c,s,f,h,u,m,v,g){return"undefined"==typeof g&&(g=0),[o,n,a,u,m,v,g,t,i,r,u,m,v,g,e,l,c,u,m,v,g,o,n,a,u,m,v,g,e,l,c,u,m,v,g,s,f,h,u,m,v,g]}var e={en:{}},l=require("$").intl,c=require("levels"),s=require("tfw.webgl"),f=require("vertex-array"),h=function(o){this._gl=o,this._prgWalls=new s.Program(o,{vert:u.vert,frag:u.frag}),this._prgGround=new s.Program(o,{vert:u["vert-ground"],frag:u["frag-ground"]})};h.prototype.loadTerrain=function(o){var n=.4,a=.2,e=0,l=.3,s=.15,h=0,u=[],m=c[o].alti,v=(m.length,m[0].length,new f);m.forEach(function(o,n){o.forEach(function(o,a){if(!(o<0)){var t=i(m,a+0,n+0,o),r=i(m,a+0,n+1,o),e=i(m,a+1,n+1,o),l=i(m,a+1,n+0,o);v.add(a+0,n+0,o,t[0],t[1]),v.add(a+0,n+1,o,r[0],r[1]),v.add(a+1,n+1,o,e[0],e[1]),v.add(a+1,n+1,o,e[0],e[1]),v.add(a+1,n+0,o,l[0],l[1]),v.add(a+0,n+0,o,t[0],t[1])}})}),this._ground=v.toBufferArrays(),m.forEach(function(o,i){o.forEach(function(o,c){if(!(o<0)){var f;f=t(m,c,i-1),f<o&&(u=u.concat(r(c+0,i+0,o,c+1,i+0,o,c+1,i+0,f,c+0,i+0,f,n,a,e,o))),f=t(m,c,i+1),f<o&&(u=u.concat(r(c+1,i+1,o,c+0,i+1,o,c+0,i+1,f,c+1,i+1,f,n,a,e,o))),f=t(m,c-1,i),f<o&&(u=u.concat(r(c+0,i+0,o,c+0,i+0,f,c+0,i+1,f,c+0,i+1,o,l,s,h,o))),f=t(m,c+1,i),f<o&&(u=u.concat(r(c+1,i+0,f,c+1,i+0,o,c+1,i+1,o,c+1,i+1,f,l,s,h,o)))}})}),console.info("[world] arrWalls.length / 7=...",u.length/7),this._arrWalls=new Float32Array(u),this._bufWalls=this._gl.createBuffer(),this._bufGroundVert=this._gl.createBuffer(),this._bufGroundElem=this._gl.createBuffer()},h.prototype.render=function(o,n,a){if(this._arrWalls){var t=this._gl,i=this._prgWalls,r=this._prgGround;t.enable(t.CULL_FACE),t.cullFace(t.BACK),t.enable(t.DEPTH_TEST),i.use(),i.$uniWidth=n,i.$uniHeight=a,i.$uniTime=o,i.$uniTimeFrag=o,i.$uniLookX=this.lookX,i.$uniLookY=this.lookY,i.$uniLookZ=this.lookZ,i.$uniLookPhi=this.lookPhi,i.$uniLookTheta=this.lookTheta,i.$uniLookRho=this.lookRho,t.bindBuffer(t.ARRAY_BUFFER,this._bufWalls),t.bufferData(t.ARRAY_BUFFER,this._arrWalls,t.STATIC_DRAW),i.enableVertexAttribFloat32Array("attPosition","attColor","attThreshold"),t.drawArrays(t.TRIANGLES,0,this._arrWalls.length/7),r.use(),r.$uniWidth=n,r.$uniHeight=a,r.$uniTime=o,r.$uniTimeFrag=o,r.$uniLookX=this.lookX,r.$uniLookY=this.lookY,r.$uniLookZ=this.lookZ,r.$uniLookPhi=this.lookPhi,r.$uniLookTheta=this.lookTheta,r.$uniLookRho=this.lookRho,t.bindBuffer(t.ARRAY_BUFFER,this._bufGroundVert),t.bufferData(t.ARRAY_BUFFER,this._ground.vert,t.STATIC_DRAW),r.enableVertexAttribFloat32Array("attPosition","attFlag"),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this._bufGroundElem),t.bufferData(t.ELEMENT_ARRAY_BUFFER,this._ground.elem,t.STATIC_DRAW),t.drawElements(t.TRIANGLES,this._ground.elem.length,t.UNSIGNED_SHORT,0)}},n.exports=h;var u={vert:"uniform float uniWidth;\nuniform float uniHeight;\nuniform float uniTime;\nuniform float uniLookX;\nuniform float uniLookY;\nuniform float uniLookZ;\nuniform float uniLookPhi;\nuniform float uniLookTheta;\nuniform float uniLookRho;\n\nattribute vec3 attPosition;\nattribute vec3 attColor;\nattribute float attThreshold;\n\nvarying vec3 varColor;\nvarying vec3 varPosition;\nvarying float varThreshold;\n\nconst float DEPTH = 270.0;\nconst float ZOOM = 100000.0;\n\nconst float PI = 3.141592653589793;\n  \nvoid main() {\n  float theta = uniLookTheta;\n  float phi = uniLookPhi;\n  float rho = uniLookRho;\n  float lookX = uniLookX;\n  float lookY = uniLookY;\n  float lookZ = uniLookZ;\n\n  float cosPhi = cos(phi);      // 1\n  float sinPhi = sin(phi);      // 0\n  float cosTheta = cos(theta);  // 1\n  float sinTheta = sin(theta);  // 0\n  \n  float camX = cosPhi * cosTheta;    // 1\n  float camY = cosPhi * sinTheta;    // 0\n  float camZ = sinPhi;               // 0\n\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\n\n  camX = camX * rho + lookX;\n  camY = camY * rho + lookY;\n  camZ = camZ * rho + lookZ;\n\n  mat3 cameraMat = mat3(camVX.x, camVY.x, camVZ.x,\n                        camVX.y, camVY.y, camVZ.y,\n                        camVX.z, camVY.z, camVZ.z);\n\n  vec3 pos = cameraMat * (attPosition - vec3(camX, camY, camZ));\n  float zz = pos.z;\n  float xx = pos.x / uniWidth;\n  float yy = pos.y / uniHeight;\n  float w = ZOOM / (rho * (DEPTH + zz));\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\n  \n  varColor = attColor; \n  varPosition = attPosition;\n  varThreshold = attThreshold;\n}                \n",frag:"precision mediump float;\n\nuniform float uniTimeFrag;\nvarying vec3 varColor;\nvarying vec3 varPosition;\nvarying float varThreshold;\n\nconst float PI = 3.141592653589793;\n\nconst vec4 BLUE = vec4(0.0, 0.0, 1.0, 1.0);\nconst vec4 GREEN = vec4(0.0, 0.7, 0.0, 1.0);\nconst vec4 WATER = vec4(0.5, 0.5, 1.0, 0.0);\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\n\nvoid main() {\n  // Niveau de la mer qui fluctue avec le temps.\n  float sea = -1.0 + sin(uniTimeFrag * .0010157) * .2;\n  float alpha;\n\n  // Couleur de base\n  gl_FragColor = vec4(varColor, 1.0);\n\n  if (varPosition.z < sea) {\n    // On est SOUS le niveau de la mer.\n    float threshold = sea - 0.2 + 0.1 * sin(4.0*(varPosition.x + varPosition.y) + uniTimeFrag * .004)\n      * sin(3.771*(varPosition.x - varPosition.y) + uniTimeFrag * .004);\n    if (varPosition.z > threshold) {\n      alpha = (varPosition.z - threshold)/(sea - threshold);\n      gl_FragColor = mix(WATER, BLUE, 1.0 - alpha);\n    } else {\n      alpha = -varPosition.z * .5;\n      gl_FragColor = mix( gl_FragColor, BLUE, alpha );\n    }\n  } else {\n    // On est au DESSUS du niveau de la mer.\n    alpha = clamp((varPosition.z + 1.0) / 8.0, 0.0, 1.0);\n    // Plus on monte, plus c'est clair.\n    gl_FragColor = mix( gl_FragColor, WHITE, alpha );\n    //LiserÃ© noir.\n    float diff = varThreshold - varPosition.z;\n    float petal = 0.2 * abs(sin((varPosition.x + varPosition.y) * 2.0 * PI));\n    if (diff > 0.0 && diff < petal) {\n      gl_FragColor = GREEN;\n    }\n    else if (diff > petal + 0.0 && diff < petal + .2) {\n      gl_FragColor = vec4(mix(gl_FragColor.rgb,\n                              vec3(0.0, 0.0, 0.0),\n                              (petal + .2 - diff) * 5.0),\n                          1.0);\n    }\n  }\n\n}\n","vert-ground":"attribute vec3 attPosition;\nattribute vec2 attFlag;\n\nvarying vec3 varPosition;\nvarying vec2 varFlag;\n\nuniform float uniWidth;\nuniform float uniHeight;\nuniform float uniTime;\nuniform float uniLookX;\nuniform float uniLookY;\nuniform float uniLookZ;\nuniform float uniLookPhi;\nuniform float uniLookTheta;\nuniform float uniLookRho;\n\nconst float DEPTH = 270.0;\nconst float ZOOM = 100000.0;\n\nconst float PI = 3.141592653589793;\n\nvoid main() {\n  float theta = uniLookTheta;\n  float phi = uniLookPhi;\n  float rho = uniLookRho;\n  float lookX = uniLookX;\n  float lookY = uniLookY;\n  float lookZ = uniLookZ;\n\n  float cosPhi = cos(phi);      // 1\n  float sinPhi = sin(phi);      // 0\n  float cosTheta = cos(theta);  // 1\n  float sinTheta = sin(theta);  // 0\n\n  float camX = cosPhi * cosTheta;    // 1\n  float camY = cosPhi * sinTheta;    // 0\n  float camZ = sinPhi;               // 0\n\n  vec3 camVZ = -vec3(camX, camY, camZ);       // (-1,0,0)\n  vec3 camVX = vec3(sinTheta, -cosTheta, 0);  // (0,-1,0)\n  vec3 camVY = cross(camVZ, camVX);           // (0,0,1)\n\n  camX = camX * rho + lookX;\n  camY = camY * rho + lookY;\n  camZ = camZ * rho + lookZ;\n\n  mat3 cameraMat = mat3(camVX.x, camVY.x, camVZ.x,\n                        camVX.y, camVY.y, camVZ.y,\n                        camVX.z, camVY.z, camVZ.z);\n\n  vec3 pos = cameraMat * (attPosition - vec3(camX, camY, camZ));\n  float zz = pos.z;\n  float xx = pos.x / uniWidth;\n  float yy = pos.y / uniHeight;\n  float w = ZOOM / (rho * (DEPTH + zz));\n  gl_Position = vec4(xx * w, yy * w, zz * 0.001, 1.0);\n\n  varPosition = attPosition;\n  varFlag = attFlag;\n}\n","frag-ground":"precision mediump float;\n\nuniform float uniTimeFrag;\n\nvarying vec3 varPosition;\nvarying vec2 varFlag;\n\nconst float PI = 3.141592653589793;\n\nconst vec4 GREEN = vec4(0.0, 1.0, 0.0, 1.0);\nconst vec4 DARK_GREEN = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid main() {\n  float d = max(abs(varFlag.x), abs(varFlag.y));\n  gl_FragColor = mix(GREEN, DARK_GREEN, d);\n}\n"};n.exports._=a});
//# sourceMappingURL=world.terrain.faces.js.map